This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-04-30T05:13:30.747Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
asm.txt
go.mod
lexer.go
main.go
mov.go
read.go
README.md
types.go

================================================================
Files
================================================================

================
File: asm.txt
================
MOVW R4, 0
MOVT R4, 0x3F20
ADD R2, R4, 0x08
LDR R3, (R2)
ORR R3, R3, 0x00000008
STR R3, (R2)
ADD R3, R4, 0x1C
MOVW R2, 0x0000
MOVT R2, 0x0020
STR R2, (R3)
MOVW R5, 0xFFFF
MOVT R5, 0x000F
SUBS R5, R5, 0x01
BPL -3 0xFFFFFD
ADD R3, R4, 0x28
MOVW R2, 0x0000
MOVT R2, 0x0020
STR R2, (R3)
MOVW R5, 0xFFFF
MOVT R5, 0x000F
SUBS R5, R5, 0x01
BPL -3 0xFFFFFD
B -18 0xFFFFEE

================
File: go.mod
================
module github.com/robertjshirts/rogasmic

go 1.24.2

================
File: lexer.go
================
package main

import "unicode"

type Lexer struct {
	input   string
	pos     int
	readPos int
	ch      byte
	line    int
}

func NewLexer(input string, line int) *Lexer {
	l := &Lexer{
		input:   input,
		line:    line,
		readPos: 0,
	}
	l.readChar()
	return l
}

func (l *Lexer) readChar() {
	if l.readPos >= len(l.input) {
		l.ch = 0
	} else {
		l.ch = l.input[l.readPos]
	}
	l.pos = l.readPos
	l.readPos++
}

func (l *Lexer) peekChar() byte {
	if l.readPos >= len(l.input) {
		return 0
	}
	return l.input[l.readPos]
}

func (l *Lexer) readIdentifier() string {
	start := l.pos
	for isLetter(l.ch) || isDigit(l.ch) {
		l.readChar()
	}
	return l.input[start:l.pos]
}

func (l *Lexer) readNumber() (string, TokenType) {
	start := l.pos
	// hex?
	if l.ch == '0' && (l.peekChar() == 'x' || l.peekChar() == 'X') {
		l.readChar() // 0
		l.readChar() // x
		for isHexDigit(l.ch) {
			l.readChar()
		}
		return l.input[start:l.pos], TokenHexNumber
	}

	// decimal
	for isDigit(l.ch) {
		l.readChar()
	}

	return l.input[start:l.pos], TokenNumber
	// No binary. fuck binary. me and my homies hate binary
}

func (l *Lexer) nextToken() Token {
	var tok Token

	for unicode.IsSpace(rune(l.ch)) {
		l.readChar()
	}

	tok.Line = l.line
	tok.Col = l.pos

	switch l.ch {
	case 0:
		tok = Token{Type: TokenEOF, Value: "", Line: l.line, Col: l.pos}
	case ',':
		tok = Token{Type: TokenComma, Value: string(l.ch)}
	case '(':
		tok = Token{Type: TokenLParen, Value: string(l.ch)}
	case ')':
		tok = Token{Type: TokenRParen, Value: string(l.ch)}
	case ';':
		panic("Comment not implemented")
	default:
		if unicode.IsLetter(rune(l.ch)) {
			lit := l.readIdentifier()
			tok.Value = lit
			tok.Type = TokenIdentifier
			if isRegisterLiteral(lit) {
				tok.Type = TokenRegister
			}
			return tok
		}

		if unicode.IsDigit(rune(l.ch)) {
			start := l.pos
			lit, typ := l.readNumber()
			return Token{Type: typ, Value: lit, Line: l.line, Col: start}
		}

		tok = Token{Type: TokenError, Value: string(l.ch), Line: l.line, Col: l.pos}
	}

	return tok
}

func LexLine(line string, lineNo int) []Token {
	l := NewLexer(line, lineNo)
	var tokens []Token
	for tok := l.nextToken(); tok.Type != TokenEOF; tok = l.nextToken() {
		if tok.Type == TokenError {
			panic("Lexer error: " + tok.Value)
		}
		tokens = append(tokens, tok)
	}
	return tokens
}

func isRegisterLiteral(lit string) bool {
	if len(lit) < 2 {
		return false
	}
	if lit[0] != 'R' && lit[0] != 'r' {
		return false
	}
	for i := 1; i < len(lit); i++ {
		if !unicode.IsDigit(rune(lit[i])) {
			return false
		}
	}
	return true
}

func isDigit(ch byte) bool {
	return ch >= '0' && ch <= '9'
}

func isLetter(ch byte) bool {
	return (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z')
}

func isHexDigit(ch byte) bool {
	return (ch >= '0' && ch <= '9') || (ch >= 'a' && ch <= 'f') || (ch >= 'A' && ch <= 'F')
}

================
File: main.go
================
// 32 bit arm assembler
package main

import (
	"bufio"
	"log"
	"os"
)

func main() {
	//var instructions []Instruction
	file, err := os.Open("asm.txt")
	if err != nil {
		log.Fatal(err)
	}
	defer file.Close()

	scanner := bufio.NewScanner(file)
	lineNo := 0
	for scanner.Scan() {
		line := scanner.Text()
		_, err := parseLine(line, lineNo)
		if err != nil {
			log.Printf("Error parsing line: %s, error: %v", line, err)
			os.Exit(1)
		}
		lineNo++
	}

	if err := scanner.Err(); err != nil {
		log.Fatal(err)
	}
}

func parseLine(line string, lineNo int) (Instruction, error) {
	toks := LexLine(line, lineNo)
	// print tokens for testing and return
	for _, tok := range toks {
		log.Printf("Token: Type: %v, Value: %s, Line: %d, Col: %d", tok.Type, tok.Value, tok.Line, tok.Col)
	}
	return nil, nil
}

================
File: mov.go
================
package main

import (
	"fmt"
	"strconv"
	"strings"
)

type MOVInstruction struct {
	opcode         OpCode
	condition      CondCode
	DestRegister   uint32
	ImmediateValue uint32
}

func (i *MOVInstruction) GetOperation() OpCode {
	return i.opcode
}

func (i *MOVInstruction) GetCondition() CondCode {
	return i.condition
}

func NewMOVInstruction(opcode OpCode, condition CondCode) (*MOVInstruction, error) {
	if opcode != MOVW && opcode != MOVT {
		return nil, fmt.Errorf("invalid opcode: %s", opcode)
	}

	return &MOVInstruction{
		opcode:    opcode,
		condition: condition,
	}, nil
}

func (i *MOVInstruction) GetOperands(base int) []string {
	return []string{strconv.FormatInt(int64(i.DestRegister), base), strconv.FormatInt(int64(i.ImmediateValue), base)}
}

// Takes the assembly line, sans operator and condition code, and parses it into the struct
// Operands should not have any parenthesis, commas, spaces, or comments, or the MOV instruction
func (i *MOVInstruction) ParseOperands(operands []string) error {
	if len(operands) != 2 {
		return fmt.Errorf("invalid operands: %s", operands)
	}

	register, err := strconv.ParseInt(strings.ReplaceAll(operands[0], "R", ""), 10, 8)
	if err != nil || register < 0 || register > 15 {
		return fmt.Errorf("invalid register: %s", operands[0])
	}
	i.DestRegister = uint32(register)

	immediate, err := strconv.ParseInt(operands[1], 10, 16)
	if err != nil {
		return fmt.Errorf("invalid immediate value: %s", operands[1])
	}
	i.ImmediateValue = uint32(immediate)

	return nil
}

func (i *MOVInstruction) ToMachineCode() []byte {
	var binary uint32
	// binary |= CondBits[i.condition] << 28
	binary |= 3 << 24 // 3 bits for MOV opcode
	// binary |= OpBits[i.opcode] << 20
	binary |= (i.ImmediateValue >> 12) & 0x000F // Top 4 bits of immediate
	binary |= i.DestRegister << 12
	binary |= i.ImmediateValue & 0x0FFF // Bottom 12 bits of immediate
	machineCode := make([]byte, 4)
	machineCode[0] = byte((binary >> 24) & 0xFF)
	machineCode[1] = byte((binary >> 16) & 0xFF)
	machineCode[2] = byte((binary >> 8) & 0xFF)
	machineCode[3] = byte(binary & 0xFF)
	fmt.Printf("%02X %02X %02X %02X\n", machineCode[0], machineCode[1], machineCode[2], machineCode[3])
	return machineCode
}

// Expected output for MOVW R4, 0
// Binary 1110 0011 0000 0000 0100 0000 0000 0000
// Hex E3 00 40 00
// Little endian hex 00 40 00 E3

================
File: read.go
================
package main

// The operations

================
File: README.md
================
# Assembly... Parser? Assembler? Compiler? IDK Man 

ORGASMIC
Outrageous Robbie's Golang ASM Interpreter/Compiler

================
File: types.go
================
package main

// Tokens
type TokenType int

const (
	TokenEOF TokenType = iota
	TokenError
	TokenIdentifier
	TokenRegister
	TokenSBit
	TokenNumber
	TokenHexNumber

	TokenComma
	TokenLParen
	TokenRParen
	TokenSemicolon

	Comment
)

type Token struct {
	Type  TokenType
	Value string
	Line  int
	Col   int
}

type CondCode uint8

const (
	CondAL CondCode = iota
	CondPL
)

var CondMeta = [...]struct {
	Name string
	Bits uint32
}{
	CondAL: {"AL", 0b1110},
	CondPL: {"PL", 0b0101},
}

// Opcodes
type OpCode uint32

const (
	MOVW OpCode = iota // Move bottom half of word
	MOVT               // Move top half of word
	LDR                // Load into register
	STR                // Save from register
	ADD                // Add
	SUB                // Subtract
	ORR                // Bitwise OR
	B                  // Branch
)

var OpCodeMeta = [...]struct {
	Name string
	Bits uint32
}{
	MOVW: {"MOVW", 0b0010},
	MOVT: {"MOVT", 0b0010},
}

type Instruction interface {
	GetOperation() OpCode
	GetCondition() CondCode
	ParseOperands([]string) error
	ToMachineCode() []byte
}
